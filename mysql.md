# MySQL

## 什么是主键？外键

Primary Key identifies the records in a table uniquely.  
Foreign Key is used to link the tables.

# 什么是 join？

join:从两张或多张表中读数据  
inner join:selects records that have matching values in both tables.(需指明那一列)  
left outer join:保留左表的所有数据，匹配右表的数据，如果没有就 null  
right outer join:同上  
natural join:自动匹配名字相同的列，会导致意外情况  
join 时用 using 和 on 的区别:using 会去掉重复的一列  
cross join: give the cartisian product result 笛卡尔积(对每一列，匹配所有的列)

## 存储过程&函数

存储、组织、优化 sql，加强安全性

## 事务 ACID 特性

transaction: a group of statements that perform in one single work. can be commited or rollback.
Atomic 原子性：事务不可分割，要么全执行，要么全不执行  
Consistency 一致性：事务开始前、结束后数据库状态一致（银行转帐，有进有出）  
Isolation 隔离性：事务可并发执行，但对于一个事务感知不到另外的事务  
Durability 持久性：对数据库的操作是永久的

## 两阶段更新

### 第一阶段：Prepare 阶段

写入 redo log，标记为 PREPARE 状态

写入 binlog，记录事务事件

刷盘：将 redo log 和 binlog 都持久化到磁盘

如果两者都成功，进入第二阶段；否则回滚事务

### 第二阶段：Commit 阶段

更新 redo log 状态为 COMMIT

标记 binlog 为已提交

释放锁、清理 undo log，事务正式完成

### 故障恢复场景

如果 MySQL 在 commit 前崩溃，重启后会检查 redo log 是否处于 PREPARE 状态

如果 binlog 已写入，说明事务可提交 → redo log 补写 COMMIT

如果 binlog 未写入，说明事务失败 → redo log 回滚

## 页

mysql 管理存储空间的基本单位，内存和磁盘交互的基本单位。16KB。索引也是记录在页中，一个页就是一个索引的叶子/非叶子节点，页和页之间是双向链表。

## 索引

用来快速查找符合某些条件的数据，提高查询性能  
b+树，非叶子结点存放的是指向下一层的指针，叶子结点存放的是主键，通过主键去获得整条数据。
只有主键是一级索引(primary 且 cluster)，我们自己创建的都是二级索引

## 覆盖索引

查询的每一个属性都能通过查询某一个索引获得，不需遍历数据表

```sql
#有一个(name,phone)的联合索引
select name where phone="xxx"
#虽然不满足最左匹配，但是mysql会优化为覆盖索引，所以也会走索引
```

## 聚集(cluster)索引/非聚集索引

如果记录按照索引码的顺序排列，则该索引是聚集索引  
每张表仅一个聚集索引  
只有聚集索引能是稀疏索引

## 稀疏(sparse)索引/稠密(dense)索引

稠密：为索引码的每个值都创建索引

## 复合(union)索引

索引包含多个属性

## 最左匹配原则

检索数据时从联合索引的最左边开始匹配  
eg: 索引(a,b,c)  
where a = 1 and b = 1(yes)  
where a = 1 and c = 1(yes 只用到了索引 a)  
where b = 1 and c = 1(未命中)

## 遇到慢查询怎么办

```sql
    explain select ...
```

用 explain 看下 sql 是怎么执行的，是否扫全表，是否命中了索引
打开慢查询日志

```lni
slow_query_log = 1
long_query_time = 1
```

查看慢查询语句：

```bash
tail -f /var/log/mysql/slow-query.log
```

## 有哪些存储引擎

INNODB(用于安全性要求高，频繁 update 的场景)：

1. 支持事务
2. 唯一支持外键约束
3. 自动灾难恢复
4. 支持 auto_increment

MYISAM(用于较少的 update，较多的 select 的场景):

1. 每次查询有原子性，速度快，无事务
2. 允许没有索引和主键，索引保存行地址

## 并发问题 & 隔离等级

## MySQL Isolation Levels Comparison

| Isolation Level               | 脏读 Dirty Read （读到了另一个事务未提交的数据）                                  | 不可重复读 Non-repeatable Read（当前事务两次读取数据，同一行的结果不同(中间有一个别的事务修改了数据) ） | 幻读 Phantom Read（当前事务两次读取数据，第二次读到了第一次没读到的数据(中间有一个别的事务插入了数据)） | Locking Behavior                                       |
| ----------------------------- | --------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------- | ------------------------------------------------------ |
| **读未提交 READ UNCOMMITTED** | 不可解决                                                                          | 不可解决                                                                                                | 不可解决                                                                                                | No locks; reads uncommitted changes.                   |
| **读已提交 READ COMMITTED**   | 可解决（通过 mvcc，每次查询生成一个新的 read view，只包含已提交的事务生成的数据） | 不可解决（因为他是每次查询创建 view， 不是事务一开始就创建）                                            | 不可解决                                                                                                |                                                        |
| **可重复读 REPEATABLE READ**  | 可解决                                                                            | 可解决（事务开始时创建一个 read view，记录哪些事务是活跃的，每次查询根据事务版本判断哪些版本可读）      | 可解决（使用临键锁（行+间隙），不允许插入新纪录）                                                       |                                                        |
| **串行化 SERIALIZABLE**       | ❌ Prevented                                                                      | ❌ Prevented                                                                                            | ❌ Prevented                                                                                            | 可串行化会对所有读操作加共享锁，使用范围锁锁定查询区间 |

## innodb 锁定

**共享锁独占锁**：行级锁，有共享锁可以继续上共享锁，但是不能上独占锁。有独占锁就都不能上  
**意向锁**：表级锁，在获得共享/独占锁之前，必须先获得意向锁

## mysql 执行过程

查询语句：

1. 客户端将 SQL 语句通过驱动发送到连接池
1. (8.0 开始没有这一步)进入查询缓存查询，有的话直接通过连接池返回(为什么没有了？查缓存命中率不高，还需要新建缓存，修改后批量失效，开销较大)
1. 通过 SQL 解析器解析 SQL 语句(词法分析，语法分析)
1. 解析完后通过预处理器，提交语句模版(可复用，如一个模版不同参数)和参数(会验证参数，如表、字段是否存在)
1. SQL 优化(基于成本，选择成本最小的路径，通过索引，表的大小等计算出 IO 和 CPU 消耗)
1. 经过上述步骤，sql 语句变成了执行计划，由执行器来执行(调用存储引擎的 handler API)
1. 获取结果后返回

**磁盘与内存交互的最小单位**：页(16KB)，页中地址是连续的。一个区(1MB)存 64 个连续的页。一个组(256MB)存 256 个区

**每行数据长度限制**：64KB，页中一行的大小为 8KB，超过 8KB 的数据存在溢出页(只针对 varchar，varbinary)
UTF8MB4 字符集下的最大 VARCHAR 长度是 21844，varchar 存在页外，主行只存指针 + 前 768 字节

**每个表最多 4096 个字段**(受到每行长度 8KB 的限制，如果全是 8B 的字段，那只能有 1000 个字段)

## MVCC Multi-Version Concurrency Control only in innodb

每行数据维护多个版本，读操作读取符合可见性规则的版本，而写操作创建新版本。用处是在读写的场景下，读不加锁也可以读到某一版本的快照。可解决 RU 隔离级别下的脏读和 RC 级别下不可重复读的问题

当前读：读取最新版本数据，并且要保证其他事务不会修改当前数据，当前读需要加锁，如 `select... lock in share mode(共享锁)` `select... for update(排他锁)`  
快照读：innoDB 根据 Read View 判断哪些版本是当前事务可见的，优点是每次读不加锁，缺点是可能读到不是最新的版本。一般的查询都是快照读。

1. select：使用 read view 判断哪些版本可见
2. insert：为新插入的记录设置当前事务 id，回滚指针为空
3. update：原始记录写进 undo log，trx id 更新，回滚指针指向 undo log 里，修改数据为新值
4. delete：原始记录写进 undo log，trx id 更新，回滚指针指向 undo log，设置一个隐藏的删除位 delete flag

### MVCC 实现原理

每行都有隐藏字段（隐藏主键 row_id、事务 ID trx_id、回滚指针指向上一个版本 roll_pointer）以及 undo log 和 ReadView
版本链：修改记录时 rollpointer 会指向上一版本那一行

## 索引失效的场景

1. 不满足最左前缀原则，联合索引必须从最左边的字段开始匹配
2. 使用了函数表达式，如 year()
3. 使用了 like+通配符
4. 使用 or 并且某个条件没有走索引
5. 使用了!=,<>
6. 数据分配不均，字段重复率高，如性别，，会被优化器忽略

## 为什么索引用 b+树

1. 磁盘访问高效：非叶子节点不存储数据，使层数少，减少了磁盘读取次数
2. 数据在叶子节点，并且按顺序排列，便于范围查询和排序，叶子节点通过链表链接，遍历高效
3. 数据库读取以页为单位，b+树节点适配磁盘结构
4. 结构矮胖，查询路径短

B 树的缺点是非叶子节点也存数据，导致树层数变高  
红黑树节点只存一个键，树高，磁盘访问多  
哈希表不支持范围查询  
跳表用于内存

## 乐观锁 & 悲观锁

乐观：假设冲突不太可能发生，不加锁，提交更新时才检查冲突，可以通过加版本号和时间戳字段在表中，并且实现相应的逻辑
悲观：假设冲突总是发生，在访问数据前就加锁，防止其他事务修改，比如 select for update， lock tables write；

## 行锁 record lock (innodb)

加在索引记录上的锁，锁某一行，粒度小，基于索引实现，没有索引会退化成表锁，必须在事务中并且使用加锁语句如 for update

## 间隙锁 Gap Lock (innodb)

锁定的是两个索引记录之间的“间隙”，而不是具体的记录。防止其他事务在该间隙中插入新记录

### 临键锁（Next-Key Lock）

临键锁是 行锁 + 间隙锁 的组合，锁定当前记录和前一个记录之间的间隙，防止插入及更新。默认在 RR 隔离级别下使用。用于解决幻读问题。

## insert 的时候会写哪些 log / 日志写入顺序

1. 事务开始，分配事务 ID
2. 写入 Undo log：记录修改前的数据（对于 insert 是空值）
3. 修改数据页：在内存中执行插入操作
4. 写入 Redo log buffer：记录数据页的变更
5. 写入 binlog：在事务提交之前记录逻辑操作
6. 两阶段提交：
   prepare 阶段： 将 redo log 标记为准备提交
   commit 阶段：先写 binlog，再将 redo log 标记为已提交
7. 刷盘：将 redo log 和 binlog 持久化
8. 数据文件更新：将数据页异步刷新到磁盘

Undo log：innodb 层面的 log，记录了修改之前的数据
Redo log：innodb 层面的 log，记录了在某个数据页上做什么修改
binlog：mysql server 层面的 log，记录每个语句的原始逻辑，用于数据备份

## 集群模式

**主从复制模式**：主库负责写操作，从库负责读操作，支持异步、半同步、组复制（强一致性）。缺点：主库故障需手动切换，存在数据延迟
**双主模式**：两个主库互为主从，支持双主双写（冲突风险高）或双主单写（推荐），提高写可用性，但配置复杂，需冲突解决机制
**分库分表**：垂直拆分：按业务模块拆分库，水平拆分：按主键范围拆分表，需配合中间件（如 ShardingSphere、MyCat）实现路由与事务控制

## 数据库缓存一致性

常见缓存设计：
**Cache Aside（旁路缓存模式）✅ 最常用**

读操作：先查缓存，未命中则查数据库并回填缓存  
写操作：先更新数据库，再删除缓存（推荐），或更新缓存

**Write Through（直写缓存）**

所有读写都通过缓存，缓存负责同步数据库  
写入时同时更新缓存和数据库

**Write Behind（回写缓存）**
写入缓存，异步更新数据库  
性能高，但一致性风险大

问题场景及解决：

读多写少：Cache Aside + 延时双删（写数据库 → 删除缓存 → 延迟一段时间后再次删除缓存，防止并发读请求在第一次删除后重建旧缓存）  
写多读多：加锁 + MQ 异步补偿（写数据库成功后，发送消息到队列，消费者异步删除或更新缓存，确保最终一致性，适合高并发写场景）  
强一致性要求高：binlog（监听 MySQL Binlog，实时感知数据变更，自动更新或删除缓存）+分布式事务  
缓存污染频繁： 设置合理 TTL + 热数据预加载

## 延迟双删

删除缓存 - 写 db - 等待 SQL 执行之间+线程切换时间再删除

## 分布式事务

在多个服务/数据库节点保证全部成功或全部失败

1. 两阶段提交：第一阶段所有参与者预提交并锁定资源，第二阶段统一提交或回滚
2. TCC Try Confirm Cancel：资源预留，正式提交，回滚资源
3. 消息队列异步通知其他服务
4. 本地消息+补偿

## mysql 跨 partition 查询的问题

1. 扫多个分区，性能下降（语句中加上分区的字段）
2. 每分区维护独立索引，会重复走索引树（建立复合索引）

## OLAP vs OLTP

**OLAP online analytical processing**  
对大量历史数据进行多维度分析，注重复杂查询性能，多维分析能力，数据汇总  
**OLTP online transaction processing**  
高效准确的处理日常业务事务，注重事务的实时性、并发性、数据一致性

## mysql 优化器会如何优化

**查询重写**  
简化条件、or 转 union，子查询改为 join

**执行计划生成与选择**  
基于成本模型（IO/CPU/内存），选择最优方案，如表连接顺序优化（优先过滤条件强，数据量小的表），索引选择，范围条件优化，排序优化分组优化（利用索引）

**特殊优化**  
索引下推（在扫描索引时就过滤数据），分区裁剪（只扫描符合条件的分区），延迟关联（先过滤小表的数据），派生表合并（将派生表合并到外层查询），执行缓存计划

## join 的底层算法
